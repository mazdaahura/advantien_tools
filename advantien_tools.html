<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advantien Document Parser</title>

    <!-- Version Pinned CDNs -->
    <script src="https://cdn.tailwindcss.com?v=3.4.1"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

    <!-- PDF.js Worker Configuration -->
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>

    <!-- Tailwind Configuration -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        brand: {
                            50: '#f0f7f9',
                            100: '#daecf1',
                            500: '#187992',
                            600: '#136175',
                            700: '#0f4d5d'
                        }
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                        mono: ['Fira Code', 'monospace']
                    }
                }
            }
        }
    </script>

    <style>
        /* Custom Styles & Utilities */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=Fira+Code:wght@400;500&display=swap');

        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            color: #1f2937;
        }

        .glass-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(229, 231, 235, 0.5);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        .drop-zone-active {
            border-color: #187992;
            background-color: #f0f7f9;
        }

        table {
            border-collapse: separate;
            border-spacing: 0;
            width: 100%;
        }

        th {
            position: sticky;
            top: 0;
            z-index: 10;
            background: #f8fafc;
        }

        td,
        th {
            white-space: nowrap;
        }

        #sidebar {
            overflow: hidden;
            white-space: nowrap;
        }

        /* Tooltip Styles */
        .tooltip-card {
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(8px);
            border: 1px solid #e2e8f0;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            border-radius: 0.5rem;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
        }

        .tooltip-header {
            background: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
            padding: 0.5rem 0.75rem;
            font-size: 0.75rem;
            font-weight: 600;
            color: #475569;
            text-transform: uppercase;
            letter-spacing: 0.025em;
        }

        .tooltip-body {
            padding: 0.5rem;
        }

        .tooltip-table {
            width: 100%;
            font-size: 0.75rem;
            border-collapse: collapse;
        }

        .tooltip-table td {
            padding: 3px 6px;
            vertical-align: top;
            border-bottom: 1px solid #f1f5f9;
        }

        .tooltip-table tr:last-child td {
            border-bottom: none;
        }

        .tooltip-key {
            text-align: right;
            color: #64748b;
            font-weight: 500;
            white-space: nowrap;
            padding-right: 8px;
            border-right: 1px solid #f1f5f9;
            width: 40%;
        }

        .tooltip-value {
            text-align: left;
            color: #0f172a;
            font-family: 'Fira Code', monospace;
            word-break: break-all;
            width: 60%;
        }
    </style>
</head>

<body class="flex flex-col h-full">

    <!-- App Layout -->
    <div class="flex flex-1 overflow-hidden h-full">

        <!-- Sidebar Navigation -->
        <aside id="sidebar"
            class="w-16 bg-slate-900 text-white flex flex-col transition-all duration-300 shrink-0 h-full">
            <div class="h-14 flex items-center justify-between px-3 border-b border-slate-700 shrink-0 relative">
                <!-- Brand (Truncated when collapsed) -->
                <div class="flex items-center gap-3 overflow-hidden whitespace-nowrap">
                    <div class="w-8 h-8 rounded bg-brand-500 flex items-center justify-center shrink-0">
                        <i data-lucide="file-text" class="text-white w-5 h-5"></i>
                    </div>
                    <span
                        class="font-bold text-lg tracking-tight sidebar-text hidden transition-opacity duration-300">Advantien</span>
                </div>

                <!-- Toggle/Pin Button -->
                <button id="toggle-sidebar"
                    class="text-slate-400 hover:text-white p-1 rounded-md transition-colors absolute right-3 z-20">
                    <i id="sidebar-toggle-icon" data-lucide="pin-off" class="w-4 h-4"></i>
                </button>
            </div>

            <nav class="flex-1 p-2 space-y-1" id="main-nav">
                <!-- Nav items injected via JS -->
            </nav>

            <div class="p-4 border-t border-slate-700 text-xs text-slate-400 sidebar-text hidden">
                <p>v0.1.0 â€¢ Local Build</p>
                <p id="build-date"></p>
            </div>
        </aside>

        <!-- Main Content Area -->
        <main class="flex-1 flex flex-col min-w-0 bg-gray-50 relative h-full">
            <!-- Header -->
            <header class="h-14 bg-white border-b border-gray-200 flex items-center justify-between px-4 shrink-0">
                <div class="flex items-center gap-4">
                    <h1 id="page-title" class="text-lg font-semibold text-gray-800">Document Parser</h1>
                </div>
                <div id="header-actions" class="flex items-center gap-2">
                    <!-- Actions injected via JS -->
                </div>
            </header>

            <!-- Dynamic View Container -->
            <div id="app-view" class="flex-1 overflow-hidden relative h-full">
                <!-- Views rendered here -->
            </div>
        </main>
    </div>

    <!-- Debug Panel (Hidden by default) -->
    <div id="debug-panel"
        class="fixed bottom-0 right-0 w-full md:w-2/3 h-80 bg-slate-800 text-green-400 font-mono text-xs transform translate-y-full transition-transform duration-300 z-50 border-t-2 border-brand-500 flex flex-col shadow-2xl">
        <div class="flex items-center justify-between bg-slate-900 px-4 py-2 border-b border-slate-700">
            <span class="font-bold flex items-center gap-2"><i data-lucide="terminal" class="w-4 h-4"></i> System
                Console</span>
            <div class="flex items-center gap-4">
                <button onclick="document.getElementById('debug-log').innerHTML=''"
                    class="text-slate-500 hover:text-white uppercase text-[10px] font-bold tracking-wider">Clear</button>
                <button onclick="toggleDebug()"
                    class="text-white hover:text-slate-300 flex items-center gap-1 bg-slate-700 px-2 py-1 rounded">
                    <i data-lucide="chevron-down" class="w-4 h-4"></i> Close
                </button>
            </div>
        </div>
        <div id="debug-log" class="flex-1 overflow-auto p-4 space-y-1"></div>
    </div>
    <button onclick="toggleDebug()"
        class="fixed bottom-2 right-2 p-2 bg-slate-800 text-white rounded-full shadow-lg hover:bg-slate-700 z-40 opacity-50 hover:opacity-100 transition-opacity"
        title="Toggle Debug Console">
        <i data-lucide="terminal" class="w-4 h-4"></i>
    </button>

    <!-- JavaScript Application Logic -->
    <script>
        /*************************************************************************
         * 1. APP CONFIGURATION & REGISTRIES
         *************************************************************************/

        // --- HARDCODED API KEY (User Override) ---
        const DEFAULT_API_KEY = 'PLACEHOLDER_KEY_HERE'; // Replace this string in code to hardcode

        const APP = {
            version: '0.1.1',
            buildDate: new Date().toLocaleDateString(),
            colors: { brand: '#187992' }
        };

        // UI Registry: Centralized Tailwind Class Mappings
        const UI = {
            layout: {
                container: 'max-w-7xl mx-auto px-4 sm:px-6 lg:px-8',
                card: 'bg-white rounded-lg border border-gray-200 shadow-sm glass-panel',
                section: 'p-6 mb-6',
                splitPane: 'h-full flex flex-col md:flex-row divide-y md:divide-y-0 md:divide-x divide-gray-200'
            },
            typography: {
                headingPage: 'text-2xl font-bold text-gray-900',
                headingSection: 'text-lg font-medium text-gray-900 mb-4',
                label: 'block text-sm font-medium text-gray-700 mb-1',
                subtext: 'text-xs text-gray-500',
                mono: 'font-mono text-sm'
            },
            interactive: {
                btnPrimary: 'inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-brand-500 hover:bg-brand-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-brand-500 transition-all',
                btnSecondary: 'inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-brand-500 transition-all',
                btnDanger: 'inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-red-700 bg-red-100 hover:bg-red-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500',
                btnIcon: 'p-2 rounded-md text-gray-400 hover:text-gray-500 hover:bg-gray-100 focus:outline-none',
                inputBase: 'shadow-sm focus:ring-brand-500 focus:border-brand-500 block w-full sm:text-sm border-gray-300 rounded-md p-2'
            },
            data: {
                table: 'min-w-full divide-y divide-gray-200',
                tableHeader: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-gray-50',
                tableCell: 'px-3 py-1 whitespace-nowrap text-sm text-gray-900 border-b border-gray-100',
                tableRowHover: 'hover:bg-gray-100 transition-colors cursor-pointer',
                badge: 'inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium'
            }
        };

        // #region FIELD_EXTRACTION_SCHEMA
        /**
         * FIELD_REGISTRY - Comprehensive schema defining all extractable fields
         * Each field has: displayName, type, and hardcoded aliases
         * User aliases (from Settings > Mappings) are merged at runtime via AliasEngine
         */
        const FIELD_REGISTRY = {
            // ========================================
            // META FIELDS - Document-level information
            // ========================================
            meta: {
                file_name: {
                    displayName: 'Filename',
                    type: 'string',
                    aliases: [] // System-generated, no aliases needed
                },
                parsing_method_id: {
                    displayName: 'Parsing Method',
                    type: 'string',
                    aliases: ['Parser', 'Method']
                },
                doc_type: {
                    displayName: 'Document Type',
                    type: 'string',
                    aliases: ['Type', 'DocType', 'Document']
                },
                invoice_no: {
                    displayName: 'Invoice #',
                    type: 'string',
                    aliases: ['Invoice', 'Invoice Number', 'Inv #', 'Inv No', 'Invoice No.']
                },
                so_no: {
                    displayName: 'SO #',
                    type: 'string',
                    aliases: ['Sales Order', 'S/O', 'SO', 'SO Number', 'Sales Order #']
                },
                po_no: {
                    displayName: 'PO #',
                    type: 'string',
                    aliases: ['PO', 'Purchase Order', 'P/O', 'PO Number', 'Purchase Order #', 'Order #']
                },
                mrn: {
                    displayName: 'MRN',
                    type: 'string',
                    aliases: ['Medical Record Number', 'MR#', 'Patient ID', 'Chart #']
                },
                physician: {
                    displayName: 'Physician',
                    type: 'string',
                    aliases: ['Doctor', 'Dr.', 'Surgeon', 'Provider', 'Attending']
                },
                dos: {
                    displayName: 'DOS',
                    type: 'date',
                    aliases: ['Date of Service', 'Service Date', 'Procedure Date', 'Surgery Date']
                },
                case_id: {
                    displayName: 'Case ID',
                    type: 'string',
                    aliases: ['Case #', 'Case Number', 'Surgical Case']
                },
                vendor_name: {
                    displayName: 'Vendor',
                    type: 'string',
                    aliases: ['Supplier', 'Manufacturer', 'Company']
                },
                facility: {
                    displayName: 'Facility',
                    type: 'string',
                    aliases: ['Hospital', 'Location', 'Ship To', 'Destination', 'Customer']
                },
                order_date: {
                    displayName: 'Order Date',
                    type: 'date',
                    aliases: ['PO Date', 'Purchase Date', 'Ordered']
                },
                ship_date: {
                    displayName: 'Ship Date',
                    type: 'date',
                    aliases: ['Shipping Date', 'Shipped', 'Date Shipped']
                },
                subtotal: {
                    displayName: 'Subtotal', // extracted total_items
                    type: 'currency',
                    aliases: ['Total Items', 'Subtotal per Document', 'Net Amount', 'Taxable Base', 'Sub Total']
                },
                total_tax: {
                    displayName: 'Total Tax',
                    type: 'currency',
                    aliases: ['Tax', 'Sales Tax', 'Tax Amount']
                },
                total_freight: {
                    displayName: 'Freight',
                    type: 'currency',
                    aliases: ['Shipping', 'Freight Charge', 'Delivery']
                },
                grand_total: {
                    displayName: 'Grand Total',
                    type: 'currency',
                    aliases: ['Total', 'Invoice Total', 'Amount Due', 'Total Amount']
                }
            },

            // ========================================
            // LINE ITEM FIELDS - Row-level information
            // ========================================
            lineItems: {
                qty: {
                    displayName: 'Qty',
                    type: 'number',
                    aliases: ['Quantity', 'Qty Shipped', 'Qty Ordered', 'Units', 'Count', 'Shipped']
                },
                part_number: {
                    displayName: 'Part #',
                    type: 'string',
                    aliases: ['Part Number', 'PartNo', 'Part No', 'Item #', 'Item Number',
                        'Ref #', 'Reference', 'Catalog #', 'Cat #', 'SKU', 'Product Code',
                        'GTIN', 'UPC', 'Material #', 'Material Number']
                },
                description: {
                    displayName: 'Description',
                    type: 'string',
                    aliases: ['Part Desc', 'Part Description', 'Item Description', 'Product',
                        'Product Name', 'Item', 'Material Description', 'Desc']
                },
                unit_price: {
                    displayName: 'Price/ea',
                    type: 'currency',
                    aliases: ['Price', 'Unit Price', 'Each', 'Price Each', 'Rate', 'Cost',
                        'Unit Cost', 'Price Per Unit', '$ Each', 'U/P']
                },
                ext_price: {
                    displayName: 'Price Ext',
                    type: 'currency',
                    aliases: ['Extended Price', 'Ext Price', 'Extended', 'Line Total',
                        'Total Price', 'Amount', 'Ext Amt', 'Extended Amount', 'Net']
                },
                lot_number: {
                    displayName: 'Lot #',
                    type: 'string',
                    aliases: ['Lot', 'Lot No', 'Batch', 'Batch #']
                },
                serial_number: {
                    displayName: 'Serial #',
                    type: 'string',
                    aliases: ['Serial', 'SN', 'Serial No']
                },
                expiration_date: {
                    displayName: 'Exp Date',
                    type: 'date',
                    aliases: ['Expiration', 'Expiry', 'Exp', 'Use By']
                },
                uom: {
                    displayName: 'UoM',
                    type: 'string',
                    aliases: ['Unit', 'Unit of Measure', 'UOM', 'Meas.', 'Unit Type', 'Packaging']
                }
            }
        };

        // Backward compatibility: APP_SCHEMA for existing code references
        const APP_SCHEMA = {
            meta: Object.keys(FIELD_REGISTRY.meta),
            lineItems: Object.keys(FIELD_REGISTRY.lineItems)
        };
        // #endregion FIELD_EXTRACTION_SCHEMA

        // #region ALIAS_UTILITIES
        /**
         * AliasEngine - Utility for field alias resolution and AI prompt context
         * Merges hardcoded aliases with user-defined aliases from Settings > Mappings
         */
        const AliasEngine = {
            /**
             * Get all aliases for a canonical field (hardcoded + user-defined)
             * @param {string} category - 'meta' or 'lineItems'
             * @param {string} canonicalName - The canonical field name (e.g., 'part_number')
             * @returns {string[]} - Array of lowercase aliases
             */
            getAliases(category, canonicalName) {
                const fieldDef = FIELD_REGISTRY[category]?.[canonicalName];
                if (!fieldDef) return [];

                const hardcodedAliases = fieldDef.aliases || [];
                const userAliases = Store.state.config.fieldLabelAliases?.[canonicalName] || [];

                // Merge, deduplicate, case-insensitive
                const all = [...hardcodedAliases, ...userAliases, fieldDef.displayName, canonicalName];
                return [...new Set(all.map(a => a.toLowerCase()))];
            },

            /**
             * Given an unknown field label, find its canonical name
             * @param {string} unknownLabel - The label from a document (e.g., "Ref #")
             * @param {string} category - 'meta', 'lineItems', or 'all'
             * @returns {Object|null} - { category, canonical, displayName } or null
             */
            resolveToCanonical(unknownLabel, category = 'all') {
                const labelLower = unknownLabel.toLowerCase().trim();
                const categories = category === 'all'
                    ? ['meta', 'lineItems']
                    : [category];

                for (const cat of categories) {
                    for (const [canonical, def] of Object.entries(FIELD_REGISTRY[cat] || {})) {
                        const aliases = this.getAliases(cat, canonical);
                        if (aliases.includes(labelLower)) {
                            return { category: cat, canonical, displayName: def.displayName };
                        }
                    }
                }
                return null; // Unknown field
            },

            /**
             * Build an alias context string for AI prompts
             * @returns {string} - Formatted alias reference for Gemini
             */
            buildAliasContext() {
                let context = 'Field Alias Reference (use these canonical names in your response):\n';
                for (const [cat, fields] of Object.entries(FIELD_REGISTRY)) {
                    context += `\n## ${cat === 'meta' ? 'Document-Level Fields' : 'Line Item Fields'}:\n`;
                    for (const [canonical, def] of Object.entries(fields)) {
                        const allAliases = this.getAliases(cat, canonical);
                        context += `- ${canonical}: [${allAliases.slice(0, 8).join(', ')}${allAliases.length > 8 ? '...' : ''}]\n`;
                    }
                }
                return context;
            },

            /**
             * Normalize parsed data by resolving aliases to canonical names
             * @param {Object} parsedData - Raw parsed data from AI or parser
             * @returns {Object} - Normalized data with canonical field names
             */
            normalizeData(parsedData) {
                const normalized = { meta: {}, lineItems: [] };

                // Normalize meta fields
                if (parsedData.meta) {
                    for (const [key, value] of Object.entries(parsedData.meta)) {
                        const resolved = this.resolveToCanonical(key, 'meta');
                        const canonicalKey = resolved ? resolved.canonical : key;
                        normalized.meta[canonicalKey] = value;
                    }
                }

                // Normalize line items
                if (Array.isArray(parsedData.lineItems)) {
                    normalized.lineItems = parsedData.lineItems.map(item => {
                        const normalizedItem = {};
                        for (const [key, value] of Object.entries(item)) {
                            const resolved = this.resolveToCanonical(key, 'lineItems');
                            const canonicalKey = resolved ? resolved.canonical : key;
                            normalizedItem[canonicalKey] = value;
                        }
                        return normalizedItem;
                    });
                }

                return normalized;
            },

            /**
             * Get field definition by canonical name
             * @param {string} canonicalName - The canonical field name
             * @returns {Object|null} - Field definition or null
             */
            getFieldDef(canonicalName) {
                return FIELD_REGISTRY.meta[canonicalName] ||
                    FIELD_REGISTRY.lineItems[canonicalName] ||
                    null;
            }
        };
        // #endregion ALIAS_UTILITIES

        /*************************************************************************
         * 2. STATE MANAGEMENT
         *************************************************************************/

        const Store = {
            state: {
                documents: [],          // [{ meta: {}, lineItems: [], id: '', status: 'parsed' }]
                selectedFileId: null,
                processingQueue: [],    // [{ file, status, progress }]
                config: {
                    geminiApiKey: '',
                    systemPrompt: 'You are an expert data extraction assistant for medical invoices.',
                    vendorAliases: {},
                    customerAliases: {},
                    fieldLabelAliases: {},
                    useAiOnly: false
                },
                ui: {
                    sidebarCollapsed: true,
                    sidebarPinned: false,
                    activeRoute: 'parser',
                    activeSettingsTab: 'ai-config',
                    showMetadata: true
                }
            },

            init() {
                const saved = localStorage.getItem('advantien_state');
                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        // Merge saved state cautiously
                        this.state.config = { ...this.state.config, ...parsed.config };
                        this.state.documents = parsed.documents || [];
                        this.state.ui = { ...this.state.ui, ...parsed.ui };
                        debugLog('State loaded from localStorage');
                    } catch (e) {
                        console.error('State load error', e);
                    }
                }
                this.persist();
            },

            persist() {
                localStorage.setItem('advantien_state', JSON.stringify({
                    config: this.state.config,
                    documents: this.state.documents,
                    ui: this.state.ui
                }));
            },

            update(key, value) {
                // Deep set helper could be added here, for now simple top-level
                this.state[key] = value;
                this.persist();
                // Trigger re-renders based on key logic (simplified reactive system)
                Router.renderCurrent();
            }
        };

        /*************************************************************************
         * 3. ROUTER & NAVIGATION
         *************************************************************************/

        const Router = {
            routes: {
                parser: {
                    title: 'Document Parser',
                    icon: 'file-text',
                    render: renderParserView
                },
                settings: {
                    title: 'Settings',
                    icon: 'settings',
                    subNav: ['ai-config', 'mappings', 'parser-help', 'data'],
                    render: renderSettingsView
                }
            },

            init() {
                window.addEventListener('hashchange', () => this.handleHashChange());
                this.handleHashChange(); // Handle initial load

                // Set build date
                document.getElementById('build-date').textContent = APP.buildDate;
            },

            navigate(routeId) {
                window.location.hash = routeId;
            },

            handleHashChange() {
                const hash = window.location.hash.slice(1) || 'parser';
                if (this.routes[hash]) {
                    Store.state.ui.activeRoute = hash;
                    this.renderCurrent();
                } else {
                    this.navigate('parser');
                }
            },

            renderCurrent() {
                const route = this.routes[Store.state.ui.activeRoute];
                document.getElementById('page-title').textContent = route.title;

                // Clear active view
                const viewContainer = document.getElementById('app-view');
                viewContainer.innerHTML = '';

                // Render view
                route.render(viewContainer);

                // Update Sidebar Active State
                this.renderSidebar();

                // Update Summary if on parser view
                if (Store.state.ui.activeRoute === 'parser') {
                    updateParserSummary();
                }

                // Re-initialize icons
                if (window.lucide) {
                    lucide.createIcons();
                } else {
                    console.warn('Lucide icons not loaded yet');
                }
            },

            renderSidebar() {
                const nav = document.getElementById('main-nav');
                nav.innerHTML = Object.entries(this.routes).map(([key, route]) => {
                    const isActive = Store.state.ui.activeRoute === key;
                    const activeClass = isActive
                        ? 'bg-brand-600 text-white'
                        : 'text-slate-300 hover:bg-slate-800 hover:text-white';

                    return `
                        <a href="#${key}" class="group flex items-center px-2 py-2 text-sm font-medium rounded-md ${activeClass}">
                            <i data-lucide="${route.icon}" class="mr-3 flex-shrink-0 h-6 w-6 ${isActive ? 'text-white' : 'text-slate-400 group-hover:text-white'}"></i>
                            <span class="${Store.state.ui.sidebarCollapsed ? 'hidden' : ''}">${route.title}</span>
                        </a>
                    `;
                }).join('');

                if (window.lucide) {
                    lucide.createIcons();
                }
            }
        };

        /*************************************************************************
         * 4. VIEW RENDERERS
         *************************************************************************/

        // --- View: Document Parser --- //
        function renderParserView(container) {
            container.innerHTML = `
                <div class="${UI.layout.splitPane}">
                    <!-- LEFT PANE: File Status -->
                    <div class="w-full md:w-1/4 min-w-[300px] bg-white border-r border-gray-200 flex flex-col h-full">
                        <!-- Drop Zone -->
                        <div id="drop-zone" class="m-4 p-6 border-2 border-dashed border-gray-300 rounded-lg text-center transition-colors duration-200 hover:bg-gray-50 hover:border-brand-400 cursor-pointer">
                            <div class="mx-auto w-12 h-12 bg-gray-100 text-gray-500 rounded-full flex items-center justify-center mb-3">
                                <i data-lucide="upload-cloud" class="w-6 h-6"></i>
                            </div>
                            <h3 class="text-sm font-medium text-gray-900">Upload Documents</h3>
                            <p class="mt-1 text-xs text-gray-500">Drag & drop PDFs here or click to browse</p>
                            <input type="file" id="file-input" multiple accept=".pdf" class="hidden">
                        </div>

                        <!-- AI Only Toggle -->
                        <div class="mx-4 mb-2 flex items-center justify-between text-xs">
                            <label class="flex items-center gap-2 text-gray-600 cursor-pointer select-none" title="Skip hard-coded parsers and always use Gemini AI">
                                <input type="checkbox" id="use-ai-only-toggle"
                                    ${Store.state.config.useAiOnly ? 'checked' : ''}
                                    onchange="Settings.saveConfig('useAiOnly', this.checked)"
                                    class="rounded border-gray-300 text-brand-600 focus:ring-brand-500 h-4 w-4">
                                <span>Use AI Only</span>
                            </label>
                            <span class="text-gray-400 italic" id="ai-only-status">${Store.state.config.useAiOnly ? 'Hard-coded parsers disabled' : 'Smart detection enabled'}</span>
                        </div>

                        <!-- Processing Queue -->
                        <div class="flex-1 overflow-y-auto p-0">
                            <div class="px-4 py-3 bg-gray-50 border-b border-gray-200 flex justify-between items-center sm:px-6">
                                <div class="flex items-center gap-2">
                                    <input type="checkbox" id="select-all-files" 
                                        onchange="Files.toggleAll(this.checked)"
                                        ${Store.state.documents.length > 0 && Store.state.documents.every(d => d.isChecked !== false) ? 'checked' : ''}
                                        class="rounded border-gray-300 text-brand-600 focus:ring-brand-500 h-4 w-4"
                                        title="Select/Unselect All">
                                    <h3 class="text-xs font-semibold text-gray-500 uppercase tracking-wider">Files (${Store.state.documents.length})</h3>
                                </div>
                                <div class="flex items-center gap-2">
                                    <button class="text-xs text-brand-600 hover:text-brand-700 font-medium" onclick="Files.clearSelection()" 
                                        style="${Store.state.selectedFileId ? '' : 'display:none'}">
                                        Exit Focus
                                    </button>
                                    <button onclick="Actions.clearBatch()" 
                                        class="text-gray-400 hover:text-red-500 hover:bg-red-50 p-1 rounded transition-colors"
                                        title="Clear All Files">
                                        <i data-lucide="trash-2" class="w-4 h-4"></i>
                                    </button>
                                </div>
                            </div>
                            <ul class="divide-y divide-gray-100" id="file-queue-list">
                                ${renderFileQueueItems()}
                            </ul>
                        </div>
                    </div>

                    <!-- RIGHT PANE: Output Table -->
                    <div class="flex-1 flex flex-col min-w-0 bg-gray-50 h-full">
                        <!-- Toolbar -->
                        <div class="bg-white border-b border-gray-200 px-4 py-3 flex items-center justify-between shrink-0">
                            <h2 class="text-lg font-medium text-gray-900 leading-6">Extracted Data</h2>
                            <div class="flex gap-2 items-center">
                                <label class="flex items-center gap-2 text-xs text-gray-600 mr-2 cursor-pointer">
                                    <input type="checkbox" 
                                        ${Store.state.ui.showMetadata ? 'checked' : ''} 
                                        onchange="Actions.toggleMetadata(this.checked)"
                                        class="rounded border-gray-300 text-brand-600 focus:ring-brand-500 h-4 w-4">
                                    Show Details
                                </label>
                                <!-- Clear Batch moved to sidebar -->
                                <button onclick="Actions.copyForExcel()" class="${UI.interactive.btnSecondary} text-xs">
                                    <i data-lucide="copy" class="w-4 h-4 mr-2"></i> Copy for Excel
                                </button>
                                <button onclick="Actions.downloadCSV()" class="${UI.interactive.btnPrimary} text-xs">
                                    <i data-lucide="download" class="w-4 h-4 mr-2"></i> Download CSV
                                </button>
                            </div>
                        </div>

                        <!-- Summary Area -->
                        <div class="bg-indigo-50 border-b border-indigo-100 px-4 py-2 flex items-center justify-between shrink-0">
                             <div class="text-xs text-indigo-800 flex gap-4">
                                <span><strong>Files:</strong> <span id="summary-file-count">0</span></span>
                                <span><strong>Lines:</strong> <span id="summary-line-count">0</span></span>
                             </div>
                             <div class="text-sm font-bold text-indigo-900">
                                Total Ext. Price: <span id="summary-total-price" class="font-mono">$0.00</span>
                             </div>
                        </div>

                        <!-- Table -->
                        <div class="flex-1 flex flex-col min-h-0 p-4">
                            <div class="bg-white shadow rounded-lg border border-gray-200 flex flex-col h-full overflow-hidden">
                                <div class="overflow-auto flex-1">
                                    <table class="${UI.data.table}">
                                        <thead class="bg-gray-50">
                                            <tr>
                                                ${renderTableHeaders()}
                                            </tr>
                                        </thead>
                                        <tbody class="bg-white divide-y divide-gray-200" id="output-table-body">
                                            ${renderTableRows()}
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // Event Listeners for Parser View
            const dropZone = document.getElementById('drop-zone');
            const fileInput = document.getElementById('file-input');

            dropZone.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', Files.handleFileSelect);

            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('drop-zone-active');
            });
            dropZone.addEventListener('dragleave', () => dropZone.classList.remove('drop-zone-active'));
            dropZone.addEventListener('drop', Files.handleDrop);
        }

        function renderFileQueueItems() {
            if (Store.state.documents.length === 0) {
                return `<li class="px-6 py-10 text-center text-sm text-gray-500">No files loaded</li>`;
            }
            return Store.state.documents.map(doc => {
                const status = doc.meta.parsing_method_id || 'UNKNOWN';
                const isFailed = status === 'FAILED';
                const isProcessing = status === 'Processing...';
                const isWaiting = status === 'Waiting...';
                const isUnknown = status === 'UNKNOWN';

                let icon = 'check-circle';
                let color = 'text-green-500';

                if (isFailed) { icon = 'alert-circle'; color = 'text-red-500'; }
                else if (isProcessing) { icon = 'loader'; color = 'text-blue-500 animate-spin'; }
                else if (isWaiting) { icon = 'clock'; color = 'text-gray-400'; }
                else if (isUnknown) { icon = 'help-circle'; color = 'text-amber-500'; }

                let errorMsg = doc.meta.error_message || 'Error';
                let isQuotaError = false;
                let retrySeconds = '';

                if (isFailed && errorMsg.includes('Quota exceeded') && errorMsg.includes('retry in')) {
                    isQuotaError = true;
                    const match = errorMsg.match(/retry in\s+([\d.]+)/);
                    if (match) retrySeconds = Math.ceil(parseFloat(match[1]));
                    errorMsg = `Failed. Quota Exceeded. Try again in ${retrySeconds}s.`;
                } else if (isFailed) {
                    errorMsg = 'Failed: ' + errorMsg;
                }

                return `
                    <li onclick="Files.selectFile('${doc.id}')" 
                        class="px-4 py-3 hover:bg-gray-50 cursor-pointer flex items-center justify-between transition-colors ${Store.state.selectedFileId === doc.id ? 'bg-brand-50 border-l-4 border-brand-500' : ''}">
                        <div class="flex items-center min-w-0 flex-1">
                            <input type="checkbox" 
                                onclick="event.stopPropagation(); Files.toggleFile('${doc.id}', this.checked)"
                                ${doc.isChecked !== false ? 'checked' : ''}
                                class="mr-3 rounded border-gray-300 text-brand-600 focus:ring-brand-500 h-4 w-4 shrink-0">
                            <i data-lucide="${icon}" 
                               class="w-4 h-4 mr-3 ${color} shrink-0">
                            </i>
                            <div class="min-w-0 flex-1">
                                <p class="text-sm font-medium text-gray-900 truncate" 
                                   onmouseenter="Files.showFileTooltip('${doc.id}', this)" 
                                   onmouseleave="Tooltip.hide()">
                                    ${doc.meta.file_name}
                                </p>
                                <div class="flex items-center gap-2">
                                     <p class="text-xs ${isFailed ? 'text-red-600' : 'text-gray-500'} truncate" title="${doc.meta.error_message || ''}">
                                        ${isFailed ? errorMsg : status}
                                    </p>
                                    ${isQuotaError ? `
                                        <button onclick="event.stopPropagation(); Files.retryFile('${doc.id}')" 
                                            class="p-0.5 px-1.5 bg-brand-50 text-brand-600 hover:bg-brand-100 rounded text-[10px] font-medium border border-brand-200 shadow-sm flex items-center gap-1"
                                            title="Retry AI Processing">
                                            <i data-lucide="refresh-cw" class="w-3 h-3"></i> Retry
                                        </button>
                                    ` : ''}
                                </div>
                            </div>
                        </div>
                        <button onclick="event.stopPropagation(); Files.deleteFile('${doc.id}')" 
                            class="ml-2 p-1 text-gray-400 hover:text-red-500 hover:bg-red-50 rounded-full transition-colors"
                            title="Delete File">
                            <i data-lucide="trash-2" class="w-4 h-4"></i>
                        </button>
                    </li>
                `;
            }).join('');
        }

        function renderTableHeaders() {
            const metaCols = [
                'File', 'Parsing Method', 'Type', 'Inv #', 'SO #', 'PO #',
                'MRN', 'Physician', 'DOS', 'Case ID'
            ];

            // Define columns with alignment preferences
            const itemCols = [
                { name: 'Qty', align: 'right' },
                { name: 'Part #', align: 'right' },
                { name: 'Description', align: 'left' },
                { name: 'UoM', align: 'center' }, // Added UoM
                { name: 'Price/ea', align: 'right' },
                { name: 'Price Ext', align: 'right' }
            ];

            let html = '';

            if (Store.state.ui.showMetadata) {
                html += metaCols.map(c => `<th class="${UI.data.tableHeader}">${c}</th>`).join('');
            }

            html += itemCols.map(c => {
                const alignment = c.align === 'right' ? 'text-right' : 'text-left';
                return `<th class="${UI.data.tableHeader} ${alignment}">${c.name}</th>`;
            }).join('');

            return html;
        }

        function renderTableRows() {
            const docs = Files.getVisibleDocuments();

            if (docs.length === 0) return `<tr><td colspan="15" class="px-6 py-10 text-center text-sm text-gray-500">No data available (Check filters)</td></tr>`;

            return docs.flatMap(doc => {
                // If no line items, show at least one row with meta
                const items = doc.lineItems.length ? doc.lineItems : [{}];
                return items.map(item => {
                    const metaCells = Store.state.ui.showMetadata ? `
                        <td class="${UI.data.tableCell} text-gray-500 text-xs">${doc.meta.file_name}</td>
                        <td class="${UI.data.tableCell} text-xs"><span class="${UI.data.badge} bg-gray-100 text-gray-800">${doc.meta.parsing_method_id}</span></td>
                        <td class="${UI.data.tableCell}">${doc.meta.doc_type || '-'}</td>
                        <td class="${UI.data.tableCell} font-medium">${doc.meta.invoice_no || '-'}</td>
                        <td class="${UI.data.tableCell}">${doc.meta.so_no || '-'}</td>
                        <td class="${UI.data.tableCell}">${doc.meta.po_no || '-'}</td>
                        
                        <td class="${UI.data.tableCell}">${doc.meta.mrn || '-'}</td>
                        <td class="${UI.data.tableCell}">${doc.meta.physician || '-'}</td>
                        <td class="${UI.data.tableCell}">${doc.meta.dos || '-'}</td>
                        <td class="${UI.data.tableCell}">${doc.meta.case_id || '-'}</td>
                    ` : '';

                    return `
                    <tr class="${UI.data.tableRowHover}">
                        ${metaCells}
                        
                        <td class="${UI.data.tableCell} font-mono text-right">${item.qty || '-'}</td>
                        <td class="${UI.data.tableCell} font-medium text-brand-600 text-right">${item.part_number || '-'}</td>
                        <td class="${UI.data.tableCell} max-w-xs truncate" title="${item.description}">${item.description || '-'}</td>
                        <td class="${UI.data.tableCell} text-center text-gray-500 text-xs">${item.uom || '-'}</td>
                        <td class="${UI.data.tableCell} text-right font-mono">${formatCurrency(item.unit_price)}</td>
                        <td class="${UI.data.tableCell} text-right font-mono font-bold">${formatCurrency(item.ext_price)}</td>
                    </tr>
                    `;
                }).join('');
            }).join('');
        }

        // --- View: Settings --- //
        function renderSettingsView(container) {
            const tab = Store.state.ui.activeSettingsTab || 'ai-config';

            container.innerHTML = `
                <div class="${UI.layout.container} py-6">
                    <div class="bg-white rounded-lg shadow">
                        <div class="border-b border-gray-200">
                            <nav class="-mb-px flex space-x-8 px-6" aria-label="Tabs">
                                ${['AI Config', 'Mappings', 'Parser Help', 'Data'].map(t => {
                const id = t.toLowerCase().replace(' ', '-');
                const active = tab === id;
                return `
                                        <button onclick="Settings.switchTab('${id}')"
                                            class="${active ? 'border-brand-500 text-brand-600' : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'} 
                                            whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm">
                                            ${t}
                                        </button>
                                    `;
            }).join('')}
                            </nav>
                        </div>
                        <div class="p-6">
                            ${renderSettingsTabContent(tab)}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderSettingsTabContent(tab) {
            if (tab === 'ai-config') {
                return `
                    <div class="max-w-xl space-y-6">
                        <div>
                            <label class="${UI.typography.label}">Gemini API Key</label>
                            <div class="flex items-center gap-2">
                                <input type="password" id="api-key" value="${Store.state.config.geminiApiKey}" 
                                    class="${UI.interactive.inputBase}" placeholder="AIza...">
                                <button onclick="Settings.saveConfig('geminiApiKey', document.getElementById('api-key').value)" 
                                    class="${UI.interactive.btnPrimary} shrink-0">
                                    Save
                                </button>
                                <span id="api-key-feedback" class="text-green-600 text-xs font-medium opacity-0 transition-opacity duration-300 flex items-center gap-1">
                                    <i data-lucide="check" class="w-3 h-3"></i> Saved!
                                </span>
                            </div>
                            <p class="${UI.typography.subtext} mt-1">Key is stored locally in your browser.</p>
                        </div>
                        
                        <!-- Test Connection UI -->
                        <div class="bg-slate-50 p-4 rounded-md border border-slate-200">
                            <label class="${UI.typography.label} !mb-2">Test API Connection</label>
                            <div class="flex gap-2 mb-2">
                                <button onclick="Settings.testApiConnection()" class="${UI.interactive.btnSecondary} text-xs">
                                    <i data-lucide="zap" class="w-4 h-4 mr-2 text-yellow-500"></i> Run Test
                                </button>
                            </div>
                            <div id="api-test-result" class="text-xs font-mono p-3 bg-white border border-gray-200 rounded min-h-[40px] text-gray-500">
                                Click 'Run Test' to send a "Hello" prompt to Gemini...
                            </div>
                        </div>

                        <div>
                            <label class="${UI.typography.label}">System Prompt</label>
                            <textarea id="system-prompt" rows="6" 
                                onchange="Settings.saveConfig('systemPrompt', this.value)"
                                class="${UI.interactive.inputBase}">${Store.state.config.systemPrompt}</textarea>
                        </div>
                    </div>
                `;
            } else if (tab === 'mappings') {
                return renderMappingsTab();
            } else if (tab === 'parser-help') {
                return `
                    <div class="max-w-2xl space-y-6">
                        <div>
                             <h3 class="${UI.typography.headingSection}">Parser Generator Helper</h3>
                             <p class="text-sm text-gray-600 mb-4">
                                Use this prompt to help Gemini generate hard-coded parsing logic for a specific document type.
                                Copy this prompt, paste it into a Gemini chat, and attach your sample PDF text (or file).
                             </p>
                        </div>

                         <div class="relative">
                            <label class="${UI.typography.label}">Prompt Template</label>
                            <textarea id="helper-prompt" rows="12" readonly
                                class="${UI.interactive.inputBase} font-mono text-xs bg-gray-50 text-gray-600 p-4"
                                onclick="this.select()"
                            >I need to create a JavaScript parsing function for a specific type of PDF document.
I will provide the raw text extracted from the PDF.

Please write a JavaScript function with the following signature:

\`\`\`javascript
ParserRegistry.register(
    'UNIQUE_PARSER_NAME_HERE', // e.g., 'Arthrex Invoice'
    (text) => text.includes('UNIQUE_IDENTIFIER_STRING'), // A simple check to identify this doc type
    (text) => { 
        // logic to extract data...
        return { 
            meta: { 
                // extracted fields...
            }, 
            lineItems: [
                // extracted line items...
            ] 
        }; 
    }
);
\`\`\`

The output object MUST strictly adhere to this schema schema:
${JSON.stringify(APP_SCHEMA, null, 2)}

Here is the raw text from the sample PDF:
[PASTE YOUR PDF TEXT CONTENT HERE]
</textarea>
                            <button onclick="navigator.clipboard.writeText(document.getElementById('helper-prompt').value).then(()=>alert('Copied!'))" 
                                class="absolute top-8 right-2 p-2 bg-white border border-gray-200 rounded hover:bg-gray-100 text-xs font-medium text-gray-600 shadow-sm">
                                Copy to Clipboard
                            </button>
                        </div>
                    </div>
                `;
            } else if (tab === 'data') {
                return `
                    <div class="max-w-xl space-y-6">
                         <div class="bg-red-50 p-4 rounded-md border border-red-100">
                            <h3 class="text-sm font-medium text-red-800">Danger Zone</h3>
                            <div class="mt-4">
                                <button onclick="Settings.clearAllData()" class="${UI.interactive.btnDanger}">
                                    Clear All App Data
                                </button>
                            </div>
                        </div>
                        <div class="bg-gray-50 p-4 rounded-md border border-gray-100">
                             <h3 class="text-sm font-medium text-gray-800">Export Configuration</h3>
                             <div class="mt-4">
                                <button onclick="Settings.exportConfig()" class="${UI.interactive.btnSecondary}">
                                    <i data-lucide="download" class="w-4 h-4 mr-2"></i> Export JSON
                                </button>
                             </div>
                        </div>
                    </div>
                `;
            }
        }

        // #region MAPPINGS_TAB_UI
        /**
         * Renders the Settings > Mappings tab with field alias management
         */
        function renderMappingsTab() {
            return `
                <div class="space-y-6">
                    <!-- Header with Import/Export/Reset -->
                    <div class="flex items-center justify-between pb-4 border-b border-gray-200">
                        <div>
                            <h3 class="${UI.typography.headingSection} !mb-1">Field Alias Mappings</h3>
                            <p class="text-xs text-gray-500">
                                Map document field labels to canonical names. Hardcoded aliases are shown in gray; 
                                your custom aliases are shown in blue.
                            </p>
                        </div>
                        <div class="flex gap-2">
                            <button onclick="Mappings.exportConfig()" class="${UI.interactive.btnSecondary} text-xs">
                                <i data-lucide="download" class="w-4 h-4 mr-1"></i> Export
                            </button>
                            <label class="${UI.interactive.btnSecondary} text-xs cursor-pointer">
                                <i data-lucide="upload" class="w-4 h-4 mr-1"></i> Import
                                <input type="file" accept=".json" onchange="Mappings.importConfig(event)" class="hidden">
                            </label>
                            <button onclick="Mappings.resetToDefaults()" class="${UI.interactive.btnSecondary} text-xs text-amber-600 border-amber-300 hover:bg-amber-50">
                                <i data-lucide="rotate-ccw" class="w-4 h-4 mr-1"></i> Reset
                            </button>
                        </div>
                    </div>

                    <!-- Meta Fields Section -->
                    <div>
                        <h4 class="text-sm font-semibold text-gray-700 uppercase tracking-wide mb-3 flex items-center gap-2">
                            <i data-lucide="file-text" class="w-4 h-4 text-gray-400"></i>
                            Document-Level Fields (Meta)
                        </h4>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                            ${renderFieldAliasCards('meta')}
                        </div>
                    </div>

                    <!-- Line Item Fields Section -->
                    <div>
                        <h4 class="text-sm font-semibold text-gray-700 uppercase tracking-wide mb-3 flex items-center gap-2">
                            <i data-lucide="list" class="w-4 h-4 text-gray-400"></i>
                            Line Item Fields
                        </h4>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                            ${renderFieldAliasCards('lineItems')}
                        </div>
                    </div>
                </div>
            `;
        }

        /**
         * Renders alias cards for a category (meta or lineItems)
         */
        function renderFieldAliasCards(category) {
            const fields = FIELD_REGISTRY[category];
            return Object.entries(fields).map(([canonical, def]) => {
                const hardcodedAliases = def.aliases || [];
                const userAliases = Store.state.config.fieldLabelAliases?.[canonical] || [];

                return `
                    <div class="bg-white border border-gray-200 rounded-lg p-3 shadow-sm">
                        <div class="flex items-center justify-between mb-2">
                            <div>
                                <span class="font-medium text-gray-900">${def.displayName}</span>
                                <code class="ml-2 text-xs bg-gray-100 px-1.5 py-0.5 rounded text-gray-600">${canonical}</code>
                            </div>
                            <span class="text-xs bg-indigo-50 text-indigo-600 px-2 py-0.5 rounded">${def.type}</span>
                        </div>
                        
                        <!-- Alias Tags -->
                        <div class="flex flex-wrap gap-1 mb-2 min-h-[28px]">
                            ${hardcodedAliases.map(alias => `
                                <span class="inline-flex items-center px-2 py-0.5 rounded text-xs bg-gray-100 text-gray-600">
                                    ${alias}
                                </span>
                            `).join('')}
                            ${userAliases.map(alias => `
                                <span class="inline-flex items-center px-2 py-0.5 rounded text-xs bg-blue-100 text-blue-700 group">
                                    ${alias}
                                    <button onclick="Mappings.removeUserAlias('${canonical}', '${alias}')" 
                                        class="ml-1 text-blue-400 hover:text-red-500 opacity-70 hover:opacity-100">
                                        <i data-lucide="x" class="w-3 h-3"></i>
                                    </button>
                                </span>
                            `).join('')}
                        </div>
                        
                        <!-- Add Alias Input -->
                        <div class="flex gap-1">
                            <input type="text" 
                                id="alias-input-${canonical}"
                                placeholder="Add alias..."
                                class="flex-1 text-xs px-2 py-1 border border-gray-200 rounded focus:ring-1 focus:ring-brand-500 focus:border-brand-500"
                                onkeydown="if(event.key==='Enter'){Mappings.addUserAlias('${canonical}', this.value); this.value='';}"
                            >
                            <button onclick="Mappings.addUserAlias('${canonical}', document.getElementById('alias-input-${canonical}').value); document.getElementById('alias-input-${canonical}').value='';"
                                class="px-2 py-1 text-xs bg-brand-50 text-brand-600 rounded hover:bg-brand-100 border border-brand-200">
                                <i data-lucide="plus" class="w-3 h-3"></i>
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }
        // #endregion MAPPINGS_TAB_UI

        // #region MAPPINGS_ACTIONS
        /**
         * Mappings module - Handles user alias management
         */
        const Mappings = {
            /**
             * Add a user-defined alias for a canonical field
             */
            addUserAlias(canonical, alias) {
                const trimmed = alias.trim();
                if (!trimmed) return;

                if (!Store.state.config.fieldLabelAliases) {
                    Store.state.config.fieldLabelAliases = {};
                }
                if (!Store.state.config.fieldLabelAliases[canonical]) {
                    Store.state.config.fieldLabelAliases[canonical] = [];
                }

                // Avoid duplicates (case-insensitive)
                const existing = Store.state.config.fieldLabelAliases[canonical].map(a => a.toLowerCase());
                if (existing.includes(trimmed.toLowerCase())) {
                    debugLog(`Alias "${trimmed}" already exists for ${canonical}`, 'warn');
                    return;
                }

                Store.state.config.fieldLabelAliases[canonical].push(trimmed);
                Store.persist();
                Router.renderCurrent();
                debugLog(`Added alias "${trimmed}" to ${canonical}`);
            },

            /**
             * Remove a user-defined alias from a canonical field
             */
            removeUserAlias(canonical, alias) {
                if (!Store.state.config.fieldLabelAliases?.[canonical]) return;

                Store.state.config.fieldLabelAliases[canonical] =
                    Store.state.config.fieldLabelAliases[canonical].filter(a => a !== alias);

                Store.persist();
                Router.renderCurrent();
                debugLog(`Removed alias "${alias}" from ${canonical}`);
            },

            /**
             * Export field mappings configuration as JSON
             */
            exportConfig() {
                const exportData = {
                    version: '1.0',
                    exportDate: new Date().toISOString(),
                    appVersion: APP.version,
                    fieldLabelAliases: Store.state.config.fieldLabelAliases || {},
                    vendorAliases: Store.state.config.vendorAliases || {},
                    customerAliases: Store.state.config.customerAliases || {}
                };

                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `advantien-mappings-${new Date().toISOString().slice(0, 10)}.json`;
                a.click();
                URL.revokeObjectURL(url);

                debugLog('Exported mappings configuration');
            },

            /**
             * Import field mappings configuration from JSON file
             */
            importConfig(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);

                        // Validate structure
                        if (!data.version) {
                            throw new Error('Invalid configuration file: missing version');
                        }

                        // Merge imported aliases with existing
                        if (data.fieldLabelAliases) {
                            Store.state.config.fieldLabelAliases = {
                                ...Store.state.config.fieldLabelAliases,
                                ...data.fieldLabelAliases
                            };
                        }
                        if (data.vendorAliases) {
                            Store.state.config.vendorAliases = {
                                ...Store.state.config.vendorAliases,
                                ...data.vendorAliases
                            };
                        }
                        if (data.customerAliases) {
                            Store.state.config.customerAliases = {
                                ...Store.state.config.customerAliases,
                                ...data.customerAliases
                            };
                        }

                        Store.persist();
                        Router.renderCurrent();
                        debugLog(`Imported configuration from ${file.name} (v${data.version})`);
                        alert('Configuration imported successfully!');
                    } catch (err) {
                        debugLog(`Import failed: ${err.message}`, 'error');
                        alert('Failed to import configuration: ' + err.message);
                    }
                };
                reader.readAsText(file);
                event.target.value = ''; // Reset file input
            },

            /**
             * Reset all user-defined aliases to defaults (empty)
             */
            resetToDefaults() {
                if (!confirm('This will remove all your custom aliases. Are you sure?')) return;

                Store.state.config.fieldLabelAliases = {};
                Store.persist();
                Router.renderCurrent();
                debugLog('Reset field aliases to defaults');
            }
        };
        // #endregion MAPPINGS_ACTIONS

        function renderMetaTooltip(doc) {
            // Filter out internal fields or empty values if desired
            const ignore = ['file_name', 'error_message'];
            const rows = Object.entries(doc.meta)
                .filter(([key, val]) => !ignore.includes(key) && val !== null && val !== undefined && val !== '')
                .map(([key, val]) => {
                    // Title Case the key
                    const label = key.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
                    // Format value if it's a number/currency? For now raw.
                    let displayVal = val;
                    if (typeof val === 'number' && (key.includes('price') || key.includes('total') || key.includes('tax'))) {
                        displayVal = formatCurrency(val);
                    }
                    return `
                        <tr>
                            <td class="tooltip-key">${label}</td>
                            <td class="tooltip-value">${displayVal}</td>
                        </tr>
                    `;
                }).join('');

            return `
                <div class="tooltip-card">
                    <div class="tooltip-header">File Metadata</div>
                    <div class="tooltip-body">
                        <table class="tooltip-table">
                            ${rows || '<tr><td colspan="2" class="text-center text-gray-400 italic py-2">No metadata available</td></tr>'}
                        </table>
                    </div>
                </div>
            `;
        }

        /*************************************************************************
         * 5. LOGIC CONTROLLERS
         *************************************************************************/

        const Tooltip = {
            el: null,
            init() {
                if (this.el) return;
                this.el = document.createElement('div');
                this.el.id = 'app-tooltip';
                this.el.className = 'fixed z-[100] pointer-events-none opacity-0 transition-opacity duration-150 ease-in-out max-w-sm';
                document.body.appendChild(this.el);

                // Hide on scroll to prevent detachment artifacts
                window.addEventListener('scroll', () => this.hide(), true);
                window.addEventListener('resize', () => this.hide());
            },

            show(html, target) {
                this.init();
                this.el.innerHTML = html;

                const rect = target.getBoundingClientRect();

                // Temporarily show to measure
                this.el.style.opacity = '0';
                this.el.style.display = 'block';

                const navHeight = 0; // Adjust if needed
                const gap = 12;

                const tipWidth = this.el.offsetWidth || 320;
                const tipHeight = this.el.offsetHeight || 200;

                // Default: Right aligned
                let top = rect.top;
                let left = rect.right + gap;

                // Collision Detection
                // 1. Right Edge
                if (left + tipWidth > window.innerWidth) {
                    left = rect.left - tipWidth - gap; // Flip to left
                }

                // 2. Bottom Edge
                if (top + tipHeight > window.innerHeight) {
                    top = window.innerHeight - tipHeight - gap;
                }

                // 3. Top Edge ensure
                if (top < gap) top = gap;

                this.el.style.top = `${top}px`;
                this.el.style.left = `${left}px`;

                // Reveal
                requestAnimationFrame(() => {
                    this.el.style.opacity = '1';
                });
            },

            hide() {
                if (this.el) {
                    this.el.style.opacity = '0';
                    // We don't set display:none immediately to allow fade out
                }
            }
        };

        const Files = {
            handleDrop(e) {
                e.preventDefault();
                document.getElementById('drop-zone').classList.remove('drop-zone-active');
                if (e.dataTransfer.files.length) {
                    Files.processFiles(e.dataTransfer.files);
                }
            },

            handleFileSelect(e) {
                if (e.target.files.length) {
                    Files.processFiles(e.target.files);
                }
            },

            showFileTooltip(id, targetEl) {
                const doc = Store.state.documents.find(d => d.id === id);
                if (doc && doc.meta) {
                    const html = renderMetaTooltip(doc);
                    Tooltip.show(html, targetEl);
                }
            },

            async processFiles(fileList) {
                try {
                    const files = Array.from(fileList).filter(f => f.type === 'application/pdf' || f.name.toLowerCase().endsWith('.pdf'));
                    debugLog(`Batch accepted: ${files.length} valid PDF files`);

                    if (files.length === 0) return;

                    // 1. Queue ALL files immediately
                    const queueItems = [];
                    for (let file of files) {
                        const docId = Date.now().toString(36) + Math.random().toString(36).substr(2);
                        const placeholder = {
                            id: docId,
                            meta: {
                                file_name: file.name,
                                parsing_method_id: 'Waiting...',
                                file_name: file.name,
                                parsing_method_id: 'Waiting...',
                                error_message: null
                            },
                            isChecked: true,
                            lineItems: []
                        };
                        Store.state.documents.push(placeholder);
                        queueItems.push({ file, id: docId });
                    }

                    Router.renderCurrent();

                    // 2. Process sequentially
                    for (let item of queueItems) {
                        const { file, id: docId } = item;

                        // Set status to Processing
                        const startIdx = Store.state.documents.findIndex(d => d.id === docId);
                        if (startIdx !== -1) {
                            Store.state.documents[startIdx].meta.parsing_method_id = 'Processing...';
                            Router.renderCurrent();
                        }

                        // Small yield
                        await new Promise(r => setTimeout(r, 50));

                        try {
                            debugLog(`Results for: ${file.name}`);

                            // Read Data
                            const arrayBuffer = await file.arrayBuffer();

                            if (typeof pdfjsLib === 'undefined') throw new Error("PDF.js library not loaded.");

                            const text = await ParsingEngine.extractPdfText(arrayBuffer);
                            debugLog(`Text extracted (${text.length} chars). Sending to AI...`);

                            // Store raw text for retry possibilities
                            const idx = Store.state.documents.findIndex(d => d.id === docId);
                            if (idx !== -1) {
                                Store.state.documents[idx].raw_text = text;
                            }

                            const result = await ParsingEngine.parse(text, file.name);

                            // Update Success
                            // Refresh idx in case of shift (unlikely here but safe practice)
                            const finalIdx = Store.state.documents.findIndex(d => d.id === docId);
                            if (finalIdx !== -1) {
                                Store.state.documents[finalIdx] = { ...result, id: docId, raw_text: text, isChecked: true };
                                if (Store.state.documents[finalIdx].meta.parsing_method_id === 'Processing...') {
                                    Store.state.documents[finalIdx].meta.parsing_method_id = 'PARSED_UNKNOWN';
                                }
                                Store.persist();
                                Router.renderCurrent();
                                updateParserSummary();
                                debugLog(`Done: ${file.name}`);
                            }
                        } catch (err) {
                            console.error(err);
                            debugLog(`ERROR: ${err.message}`);

                            const idx = Store.state.documents.findIndex(d => d.id === docId);
                            if (idx !== -1) {
                                Store.state.documents[idx].meta.parsing_method_id = 'FAILED';
                                Store.state.documents[idx].meta.error_message = err.message;
                                // Persist raw text even on fail if we got it
                                if (Store.state.documents[idx].raw_text) {
                                    // keep it
                                }
                                Store.persist();
                                Router.renderCurrent();
                            }
                        }
                    }
                } catch (batchErr) {
                    debugLog(`CRITICAL BATCH ERROR: ${batchErr.message}`);
                    console.error(batchErr);
                }
            },



            selectFile(id) {
                Store.state.selectedFileId = id;
                // Auto-check if selecting so it is visible
                const doc = Store.state.documents.find(d => d.id === id);
                if (doc) doc.isChecked = true;
                Store.persist();
                Router.renderCurrent();
            },

            toggleFile(id, checked) {
                const doc = Store.state.documents.find(d => d.id === id);
                if (doc) {
                    doc.isChecked = checked;

                    // If hiding the currently selected file, exit focus mode
                    if (!checked && Store.state.selectedFileId === id) {
                        Store.state.selectedFileId = null;
                    }

                    Store.persist();
                    Router.renderCurrent();
                }
            },

            toggleAll(checked) {
                Store.state.documents.forEach(d => d.isChecked = checked);
                Store.state.selectedFileId = null; // Clear focus when toggling all
                Store.persist();
                Router.renderCurrent();
            },

            getVisibleDocuments() {
                // 1. Always filter by checked status first
                const visible = Store.state.documents.filter(d => d.isChecked !== false);

                // 2. Then apply focus filter if active
                if (Store.state.selectedFileId) {
                    return visible.filter(d => d.id === Store.state.selectedFileId);
                }
                return visible;
            },

            deleteFile(id) {
                if (confirm('Are you sure you want to remove this file?')) {
                    Store.state.documents = Store.state.documents.filter(d => d.id !== id);
                    if (Store.state.selectedFileId === id) {
                        Store.state.selectedFileId = null;
                    }
                    Store.persist();
                    Router.renderCurrent();
                    debugLog(`File removed: ${id}`);
                }
            },

            async retryFile(id) {
                const doc = Store.state.documents.find(d => d.id === id);
                if (!doc || !doc.raw_text) {
                    alert('Cannot retry: Source text missing. Please re-upload the file.');
                    return;
                }

                doc.meta.parsing_method_id = 'Processing...';
                doc.meta.error_message = null;
                Router.renderCurrent();
                debugLog(`Retrying file: ${doc.meta.file_name}`);

                try {
                    const result = await ParsingEngine.parse(doc.raw_text, doc.meta.file_name);

                    const idx = Store.state.documents.findIndex(d => d.id === id);
                    if (idx !== -1) {
                        Store.state.documents[idx] = { ...result, id: id, raw_text: doc.raw_text, isChecked: true };
                        Store.persist();
                        Router.renderCurrent();
                        updateParserSummary();
                        debugLog(`Retry successful: ${doc.meta.file_name}`);
                    }
                } catch (err) {
                    debugLog(`Retry failed: ${err.message}`);
                    const idx = Store.state.documents.findIndex(d => d.id === id);
                    if (idx !== -1) {
                        Store.state.documents[idx].meta.parsing_method_id = 'FAILED';
                        Store.state.documents[idx].meta.error_message = err.message;
                        Store.persist();
                        Router.renderCurrent();
                    }
                }
            },

            clearSelection() {
                Store.state.selectedFileId = null;
                Router.renderCurrent();
            }
        };

        /*************************************************************************
         * 4b. PARSER REGISTRY (HARD-CODED PARSERS)
         *************************************************************************/

        const ParserRegistry = {
            parsers: [],

            register(name, checkFn, parseFn) {
                this.parsers.push({ name, check: checkFn, parse: parseFn });
                debugLog(`Registered parser: ${name}`);
            },

            findParser(text) {
                return this.parsers.find(p => {
                    try {
                        return p.check(text);
                    } catch (e) {
                        console.warn(`Parser check failed for ${p.name}`, e);
                        return false;
                    }
                });
            }
        };

        // --- ADD FUTURE HARD-CODED PARSERS HERE ---

        // #region ARTHREX_INVOICE_PARSER
        ParserRegistry.register(
            'Arthrex Invoice',
            (text) => text.includes('Arthrex Inc.') && text.includes('INVOICE'),
            (text) => {
                debugLog('[Arthrex Parser] Starting extraction...');

                // Helper to extract values using regex (flexible for both quoted CSV and plain text)
                const extract = (regex, input = text) => {
                    const match = input.match(regex);
                    return match ? match[1].trim() : null;
                };

                // Extract Meta Data - More flexible patterns for PDF text
                // Try multiple patterns for each field to handle different formats
                const invoiceNo = extract(/Invoice\s*(?:Number|No\.?|#)[\s:,]*["']?(\d+)["']?/i);
                const poNo = extract(/(?:PO|Purchase\s*Order)\s*(?:Number|No\.?|#)?[\s:,]*["']?([\w-]+)["']?/i);
                const soNo = extract(/Sales\s*Order[\s:,]*["']?(\d+)["']?/i);
                const orderDate = extract(/Order\s*Date[\s:,]*["']?(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4})["']?/i);
                const shipDate = extract(/Ship\s*Date[\s:,]*["']?(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4})["']?/i);

                debugLog(`[Arthrex] Meta: Inv=${invoiceNo}, PO=${poNo}, SO=${soNo}`);

                // Surgeon and Case Info
                const physician = extract(/(?:SURGEON|Surgeon)\s*(?:NAME)?[\s:,]*([A-Za-z\s\.,']+?)(?:\s{2,}|\n|$)/);
                const dos = extract(/(?:SURG|Surgery)\s*DATE[\s:,]*["']?(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4})["']?/i);
                const caseId = extract(/CASE\s*ID[\s:,]*["']?([\w\/\-]+)["']?/i);

                // Totals - Multiple pattern attempts
                const subtotal = parseFloat(
                    extract(/(?:Sub\s*-?\s*Total|Line\s*Total)[\s:$]*([\d,]+\.?\d*)/i)?.replace(/,/g, '') ||
                    extract(/\$([\d,]+\.?\d*)\s*(?=.*(?:Tax|Total))/i)?.replace(/,/g, '') ||
                    0
                );
                const totalTax = parseFloat(extract(/(?:Total\s*)?Tax[\s:$]*([\d,]+\.?\d*)/i)?.replace(/,/g, '') || 0);
                const totalFreight = parseFloat(extract(/(?:Total\s*)?Freight[\s:$]*([\d,]+\.?\d*)/i)?.replace(/,/g, '') || 0);
                const grandTotal = parseFloat(
                    extract(/(?:Grand\s*)?Total\s*(?:Amount)?[\s:$]*([\d,]+\.?\d*)/i)?.replace(/,/g, '') ||
                    extract(/Invoice\s*Total[\s:$]*([\d,]+\.?\d*)/i)?.replace(/,/g, '') ||
                    0
                );

                debugLog(`[Arthrex] Totals: Sub=${subtotal}, Tax=${totalTax}, Grand=${grandTotal}`);

                // Extract Line Items - Multiple regex patterns to try
                const lineItems = [];

                // Pattern 1: AR-XXXXX part numbers with surrounding data
                // Matches: AR-1234-56 followed by description, then numbers
                const arPartPattern = /(AR-?\d+[\w-]*)/g;
                const arParts = text.match(arPartPattern);
                debugLog(`[Arthrex] Found ${arParts?.length || 0} AR-style part numbers`);

                // Pattern 2: Look for item lines with part number, qty, and price
                // More flexible pattern for PDF text extraction
                const linePatterns = [
                    // Pattern: AR-XXXX Description Qty UoM Price Price
                    /(AR-?\d+[\w-]*)\s+(.+?)\s+(\d+)\s+(EA|PK|BX|CS|SET)\s+\$?([\d,]+\.?\d*)\s+\$?([\d,]+\.?\d*)/gi,
                    // Pattern: Part# in table format
                    /(AR-?\d+[\w-]*)[,\s]+([^,\n]+)[,\s]+(\d+)[,\s]+(EA|PK|BX|CS|SET)?[,\s]+\$?([\d,]+\.?\d*)[,\s]+\$?([\d,]+\.?\d*)/gi,
                    // Pattern: Quoted CSV format (original)
                    /"(AR-?[\w-]+)"\s*,\s*"([^"]+)"\s*,?\s*"(\d+)"\s*,\s*"(\w+)"\s*,\s*"[\d,.]+"\s*,\s*"[\d,.]+"\s*,\s*"([\d,.]+)"\s*,\s*"([\d,.]+)"/g
                ];

                for (const pattern of linePatterns) {
                    let match;
                    pattern.lastIndex = 0; // Reset regex
                    while ((match = pattern.exec(text)) !== null) {
                        const partNumber = match[1];
                        const description = match[2]?.replace(/\s+/g, ' ').trim() || '';
                        const qty = parseInt(match[3]) || 1;
                        const uom = match[4] || 'EA';
                        const unitPrice = parseFloat((match[5] || '0').replace(/,/g, ''));
                        const extPrice = parseFloat((match[6] || '0').replace(/,/g, ''));

                        // Avoid duplicates
                        if (!lineItems.some(li => li.part_number === partNumber && li.ext_price === extPrice)) {
                            lineItems.push({
                                qty,
                                part_number: partNumber,
                                description,
                                unit_price: unitPrice,
                                ext_price: extPrice,
                                lot_number: null,
                                serial_number: null,
                                expiration_date: null,
                                uom
                            });
                        }
                    }

                    // If we found items with this pattern, stop trying others
                    if (lineItems.length > 0) {
                        debugLog(`[Arthrex] Extracted ${lineItems.length} line items`);
                        break;
                    }
                }

                // If no items found, log a sample of the text for debugging
                if (lineItems.length === 0) {
                    debugLog('[Arthrex] WARNING: No line items extracted. Sample text (first 500 chars):');
                    debugLog(text.substring(0, 500).replace(/\n/g, ' | '));
                }

                // Look for lot/serial numbers if we have items
                lineItems.forEach((item, idx) => {
                    const itemPos = text.indexOf(item.part_number);
                    if (itemPos > -1) {
                        const remainingText = text.substring(itemPos, itemPos + 500);
                        item.lot_number = extract(/(?:Batch|Lot)[\s:#]*(\d+)/i, remainingText);
                        item.serial_number = extract(/Serial[\s:#]*(\w+)/i, remainingText);
                    }
                });

                return {
                    meta: {
                        file_name: null,
                        parsing_method_id: 'Arthrex_JS_v1',
                        doc_type: 'Invoice',
                        invoice_no: invoiceNo,
                        so_no: soNo,
                        po_no: poNo,
                        mrn: null,
                        physician: physician,
                        dos: dos,
                        case_id: caseId,
                        vendor_name: 'Arthrex Inc.',
                        facility: extract(/Ship\s*To[\s:,]*[^,\n]+[,\s]+([^,\n]+)/i),
                        order_date: orderDate,
                        ship_date: shipDate,
                        subtotal: subtotal,
                        total_tax: totalTax,
                        total_freight: totalFreight,
                        grand_total: grandTotal
                    },
                    lineItems: lineItems
                };
            }
        );
        // #endregion ARTHREX_INVOICE_PARSER

        // #region STRYKER_ORTHO_INVOICE_PARSER
        ParserRegistry.register(
            'Stryker Orthopaedics Invoice',
            (text) => text.includes('Stryker') && text.includes('Orthopaedics') && text.includes('Invoice'),
            (text) => {
                const lines = text.split('\n');

                // Helper to extract values using regex
                const extract = (regex, input = text) => {
                    const match = input.match(regex);
                    return match ? match[1].trim() : null;
                };

                // Meta Data Extraction
                const invoiceNo = extract(/Invoice Number:\s*["\s,]+(\d+)/);
                const invoiceDate = extract(/Invoice Date:\s*["\s,]+(\d{2}-\w{3}-\d{2})/);
                const poNo = extract(/Purchase Order Number:\s*["\s,]+([\w-]+)/);
                const soNo = extract(/Sales Order Number:\s*["\s,]+(\d+)/);
                const shipDate = extract(/Ship Date:\s*(?:\r?\n)?[^0-9]*(\d{2}-\w{3}-\d{2})/);

                // Facility extraction (Logic targets the specific shipping destination)
                const facilityMatch = text.match(/Ship To:\s*["\s,]*([^"\n\r]+)/);
                const facility = facilityMatch ? facilityMatch[1].trim() : null;

                // Totals extraction
                const subtotal = parseFloat(extract(/Sub-Total:\s*["\s,]+([\d,.]+)/)?.replace(/,/g, '') || 0);
                const totalTax = parseFloat(extract(/Tax:\s*["\s,]+([\d,.]+)/)?.replace(/,/g, '') || 0);
                const totalFreight = parseFloat(extract(/Freight\s*(?::)?\s*["\s,]+([\d,.]+)/)?.replace(/,/g, '') || 0);
                const grandTotal = parseFloat(extract(/Total:\s*["\s,]+([\d,.]+)/)?.replace(/,/g, '') || 0);

                // Line Item Extraction
                const lineItems = [];
                // Matches: Item Number, Description, Qty Ordered, Prev Shipped, Backordered, Qty Shipped, Unit Price, Ext Price
                const itemRegex = /"([\w-]+)"\s*,\s*"([^"]+)"\s*,\s*"\d+"\s*,\s*"\d+"\s*,\s*"\d+"\s*,\s*"(\d+)"\s*,\s*"([\d,.]+)"\s*,\s*"([\d,.]+)"/g;

                let match;
                while ((match = itemRegex.exec(text)) !== null) {
                    lineItems.push({
                        qty: parseInt(match[3]),
                        part_number: match[1],
                        description: match[2].replace(/\s+/g, ' ').trim(),
                        unit_price: parseFloat(match[4].replace(/,/g, '')),
                        ext_price: parseFloat(match[5].replace(/,/g, '')),
                        lot_number: null, // Stryker often provides these on separate packing slips or distinct comment lines
                        serial_number: null,
                        expiration_date: null,
                        uom: 'EA' // Standard default for these orthopedic surgical components
                    });
                }

                return {
                    meta: {
                        file_name: null,
                        parsing_method_id: 'Stryker_Ortho_JS_v1',
                        doc_type: 'Invoice',
                        invoice_no: invoiceNo,
                        so_no: soNo,
                        po_no: poNo,
                        mrn: null,
                        physician: null, // Not typically found in the main header of Stryker standard invoices
                        dos: null,
                        case_id: null,
                        vendor_name: 'Stryker Orthopaedics',
                        facility: facility,
                        order_date: null,
                        ship_date: shipDate,
                        subtotal: subtotal,
                        total_tax: totalTax,
                        total_freight: totalFreight,
                        grand_total: grandTotal
                    },
                    lineItems: lineItems
                };
            }
        );
        // #endregion STRYKER_ORTHO_INVOICE_PARSER

        const ParsingEngine = {
            async extractPdfText(arrayBuffer) {
                try {
                    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                    debugLog(`PDF Loaded. Pages: ${pdf.numPages}`);

                    let text = '';
                    for (let i = 1; i <= pdf.numPages; i++) {
                        debugLog(`Parsing page ${i}/${pdf.numPages}...`);
                        const page = await pdf.getPage(i);
                        const content = await page.getTextContent();
                        text += content.items.map(item => item.str).join(' ') + '\n';
                    }
                    return text;
                } catch (e) {
                    console.error("PDF Extraction Error", e);
                    throw new Error(`Failed to read PDF: ${e.message}`);
                }
            },

            async parse(text, fileName) {
                const timeoutPr = new Promise((_, reject) =>
                    setTimeout(() => reject(new Error('Parsing timed out (60s)')), 60000)
                );

                const parsingLogic = async () => {

                    // 1. Check Hard-Coded Parsers FIRST (unless useAiOnly is enabled)
                    const useAiOnly = Store.state.config.useAiOnly;

                    if (useAiOnly) {
                        debugLog("AI Only mode enabled. Skipping hard-coded parsers.");
                    } else {
                        debugLog("Checking for matching hard-coded parser...");
                        const localParser = ParserRegistry.findParser(text);

                        if (localParser) {
                            debugLog(`Match found: ${localParser.name}. Executing local parser...`);
                            try {
                                const result = localParser.parse(text);
                                // Ensure ID consistency
                                return {
                                    id: Date.now().toString(36), // will be overwritten by outer loop id usually, but good for safety
                                    meta: {
                                        file_name: fileName,
                                        parsing_method_id: `HARD_CODED_${localParser.name.toUpperCase().replace(/\s+/g, '_')}`,
                                        ...result.meta
                                    },
                                    lineItems: Array.isArray(result.lineItems) ? result.lineItems : []
                                };
                            } catch (localErr) {
                                console.error("Local parser failed, falling back to AI", localErr);
                                debugLog(`Local parser error: ${localErr.message}. Falling back to AI.`);
                                // Fallthrough to AI
                            }
                        } else {
                            debugLog("No hard-coded parser match. Falling back to Gemini.");
                        }
                    }

                    // 2. Prepare Key (AI Fallback)
                    const apiKey = Store.state.config.geminiApiKey || DEFAULT_API_KEY;
                    if (!apiKey || apiKey === 'PLACEHOLDER_KEY_HERE') {
                        throw new Error("No Gemini API Key provided. Please check Settings.");
                    }

                    // 3. Construct Prompt with Alias Context (AI Fallback)
                    const systemPrompt = Store.state.config.systemPrompt || "You are an expert data extraction assistant.";
                    const aliasContext = AliasEngine.buildAliasContext();
                    const prompt = `${systemPrompt}

You will be given the text content of a medical invoice/document.
Your task is to extract specific data fields and return a valid JSON object matching the EXACT schema below.

SCHEMA:
${JSON.stringify(APP_SCHEMA, null, 2)}

${aliasContext}

INSTRUCTIONS:
- Return ONLY valid JSON. 
- Do not include markdown formatting (like \`\`\`json).
- Use the CANONICAL field names from the schema (e.g., 'part_number', not 'Item #').
- If a document uses an alias (like "Ref #" for part_number), map it to the canonical name.
- If a field is not found, use null or empty string.
- Identify the 'parsing_method_id' as 'AI_GEMINI_2.5'.
- For 'lineItems', extract all available rows.

DOCUMENT TEXT:
${text.substring(0, 30000)}
                    `;

                    // 4. Call API
                    debugLog(`Sending ${text.length} chars to Gemini 2.5 (with alias context)...`);

                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: prompt }] }]
                        })
                    });

                    if (!response.ok) {
                        const errData = await response.json();
                        throw new Error(`Gemini API Error: ${errData.error?.message || response.statusText}`);
                    }

                    const data = await response.json();

                    // 5. Parse Response
                    let rawText = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (!rawText) throw new Error("Model returned no content.");

                    // Clean Code Fences
                    rawText = rawText.replace(/```json/g, '').replace(/```/g, '').trim();

                    let parsedData;
                    try {
                        parsedData = JSON.parse(rawText);
                    } catch (e) {
                        console.error("JSON Parse Error", rawText);
                        throw new Error("Failed to parse AI response as JSON.");
                    }

                    // 6. Normalize response using AliasEngine (resolve any alias field names to canonical)
                    const normalizedData = AliasEngine.normalizeData(parsedData);

                    // 7. Structure Result
                    return {
                        id: Date.now().toString(36), // Updates ID if needed, or keeps outer logic
                        meta: {
                            parsing_method_id: 'AI_GEMINI_2.5',
                            ...normalizedData.meta,
                            file_name: fileName
                        },
                        lineItems: Array.isArray(normalizedData.lineItems) ? normalizedData.lineItems : []
                    };
                };

                return Promise.race([parsingLogic(), timeoutPr]);
            }
        };

        const Settings = {
            switchTab(tab) {
                Store.state.ui.activeSettingsTab = tab;
                Router.renderCurrent();
            },
            saveConfig(key, value) {
                Store.state.config[key] = value;
                Store.persist();
                if (key === 'geminiApiKey') {
                    const msg = document.getElementById('api-key-feedback');
                    if (msg) {
                        msg.classList.remove('opacity-0');
                        setTimeout(() => msg.classList.add('opacity-0'), 2000);
                    }
                }
            },
            clearAllData() {
                if (confirm('Are you sure? This will wipe all data and settings.')) {
                    localStorage.removeItem('advantien_state');
                    window.location.reload();
                }
            },
            exportConfig() {
                const data = JSON.stringify(Store.state, null, 2);
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `advantien_config_${new Date().toISOString().slice(0, 10)}.json`;
                a.click();
            },
            async testApiConnection() {
                const resultEl = document.getElementById('api-test-result');
                const apiKey = document.getElementById('api-key').value || Store.state.config.geminiApiKey;

                if (!apiKey) {
                    resultEl.innerHTML = '<span class="text-red-600">No API Key found.</span>';
                    return;
                }

                resultEl.innerHTML = '<span class="text-blue-600 animate-pulse">Testing connection...</span>';

                try {
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: "Hello! Reply with 'Connection Successful' if you can hear me." }] }]
                        })
                    });

                    const data = await response.json();

                    if (data.error) {
                        resultEl.innerHTML = `<span class="text-red-600"><strong>Error:</strong> ${data.error.message}</span>`;
                    } else {
                        const reply = data.candidates?.[0]?.content?.parts?.[0]?.text || "No response text";
                        resultEl.innerHTML = `<span class="text-green-700 font-bold">Success!</span> <span class="text-gray-700">${reply}</span>`;
                    }
                } catch (e) {
                    resultEl.innerHTML = `<span class="text-red-600"><strong>Network Error:</strong> ${e.message}</span>`;
                }
            }
        };

        const Actions = {
            clearBatch() {
                if (confirm('Clear all parsed documents?')) {
                    Store.state.documents = [];
                    Store.state.selectedFileId = null;
                    Store.persist();
                    Router.renderCurrent();
                }
            },
            async copyForExcel() {
                // 1. Determine Headers based on current UI state
                let headers = [];
                if (Store.state.ui.showMetadata) {
                    headers.push('File', 'Parsing Method', 'Type', 'Inv #', 'SO #', 'PO #', 'MRN', 'Physician', 'DOS', 'Case ID');
                }
                headers.push('Qty', 'Part #', 'Description', 'Price/ea', 'Price Ext');

                // 2. Filter Data based on current selection
                const docs = Files.getVisibleDocuments();

                if (docs.length === 0) {
                    alert('No data to copy.');
                    return;
                }

                // 3. Build Rows
                const rows = docs.flatMap(doc => {
                    const items = doc.lineItems.length ? doc.lineItems : [{}];
                    return items.map(item => {
                        let rowData = [];

                        if (Store.state.ui.showMetadata) {
                            rowData.push(
                                doc.meta.file_name,
                                doc.meta.parsing_method_id,
                                doc.meta.doc_type,
                                doc.meta.invoice_no,
                                doc.meta.so_no,
                                doc.meta.po_no,
                                doc.meta.mrn,
                                doc.meta.physician,
                                doc.meta.dos,
                                doc.meta.case_id
                            );
                        }

                        rowData.push(
                            item.qty,
                            item.part_number,
                            item.description,
                            item.unit_price,
                            item.ext_price
                        );

                        // Clean data: replace nulls/undefined with empty string, remove tabs/newlines from content
                        return rowData.map(val =>
                            (val === null || val === undefined) ? '' : String(val).replace(/[\t\n\r]/g, ' ')
                        ).join('\t');
                    });
                });

                // 4. Combine key parts
                const tsv = [headers.join('\t'), ...rows].join('\n');

                // 5. Copy to Clipboard
                try {
                    await navigator.clipboard.writeText(tsv);
                    // Simple user feedback - could be improved with a toast
                    const btn = document.querySelector('button[onclick="Actions.copyForExcel()"]');
                    if (btn) {
                        const originalHtml = btn.innerHTML;
                        btn.innerHTML = '<i data-lucide="check" class="w-4 h-4 mr-2"></i> Copied!';
                        if (window.lucide) lucide.createIcons();
                        setTimeout(() => {
                            btn.innerHTML = originalHtml;
                            if (window.lucide) lucide.createIcons();
                        }, 2000);
                    } else {
                        alert('Copied specific data to clipboard!');
                    }
                } catch (err) {
                    console.error('Failed to copy: ', err);
                    alert('Failed to copy to clipboard.');
                }
            },
            downloadCSV() {
                const docs = Files.getVisibleDocuments();
                const rows = docs.flatMap(d => d.lineItems.map(item => ({ ...d.meta, ...item })));
                const csv = Papa.unparse(rows);
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'parsed_data.csv';
                a.click();
            },
            toggleMetadata(show) {
                Store.state.ui.showMetadata = show;
                Store.persist();
                Router.renderCurrent();
            }
        };

        function updateParserSummary() {
            // Only update if elements exist (i.e., we are in parser view)
            const countEl = document.getElementById('summary-file-count');
            const linesEl = document.getElementById('summary-line-count');
            const totalEl = document.getElementById('summary-total-price');

            if (!countEl || !totalEl) return;

            const docs = Files.getVisibleDocuments();
            const fileCount = new Set(docs.map(d => d.id)).size;

            let lineCount = 0;
            let totalPrice = 0;       // Calculated from line items sum
            let extractedSubtotal = 0; // Sum of doc.meta.subtotal

            docs.forEach(doc => {
                // Sum extracted subtotal
                const sub = parseFloat(String(doc.meta.subtotal).replace(/[^0-9.-]+/g, '')) || 0;
                extractedSubtotal += sub;

                if (doc.lineItems) {
                    lineCount += doc.lineItems.length;
                    doc.lineItems.forEach(item => {
                        // Ensure ext_price is treated as a number
                        const price = parseFloat(String(item.ext_price).replace(/[^0-9.-]+/g, '')) || 0;
                        totalPrice += price;
                    });
                }
            });

            countEl.textContent = fileCount;
            if (linesEl) linesEl.textContent = lineCount;

            // Logic to display comparison
            // Only compare if we actually extracted a subtotal
            if (extractedSubtotal > 0) {
                const diff = Math.abs(extractedSubtotal - totalPrice);
                const isMatch = diff < 0.05; // 5 cent tolerance for rounding

                if (isMatch) {
                    totalEl.innerHTML = `
                        <div class="flex items-center gap-2 text-green-700" title="Extracted Subtotal matches Line Item Sum">
                            <i data-lucide="check-circle" class="w-4 h-4"></i>
                            <span class="text-xs uppercase font-semibold">Verified Total:</span>
                            <span class="font-mono font-bold text-base">${formatCurrency(totalPrice)}</span>
                        </div>
                    `;
                } else {
                    totalEl.innerHTML = `
                        <div class="flex items-center gap-3 text-red-600 bg-red-50 px-2 py-1 rounded border border-red-200">
                            <i data-lucide="alert-triangle" class="w-4 h-4 shrink-0"></i>
                            <div class="flex flex-col leading-none">
                                <span class="text-[10px] uppercase font-bold mb-0.5">Mismatch Detected</span>
                                <span class="font-mono text-xs">
                                    Doc: ${formatCurrency(extractedSubtotal)} â‰  Calc: ${formatCurrency(totalPrice)}
                                </span>
                            </div>
                        </div>
                    `;
                }
            } else {
                // Fallback: No subtotal extracted, just show calculated
                totalEl.innerHTML = `
                    <span class="text-xs uppercase text-indigo-400 font-semibold mr-2">Calc Total:</span>
                    <span class="font-mono">${formatCurrency(totalPrice)}</span>
                `;
            }

            if (window.lucide) lucide.createIcons();
        }

        // --- Utils & Debug ---
        function formatCurrency(val) {
            if (!val && val !== 0) return '-';
            const num = parseFloat(String(val).replace(/[^0-9.-]+/g, ''));
            if (isNaN(num)) return val;
            return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(num);
        }

        function debugLog(msg) {
            const el = document.getElementById('debug-log');
            if (el) {
                const line = document.createElement('div');
                line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
                el.appendChild(line);
                el.scrollTop = el.scrollHeight;
            }
            console.log(msg);
        }

        function toggleDebug() {
            const panel = document.getElementById('debug-panel');
            panel.classList.toggle('translate-y-full');
        }

        // --- Boot ---
        const sidebar = document.getElementById('sidebar');

        sidebar.addEventListener('mouseenter', () => {
            if (!Store.state.ui.sidebarPinned) {
                updateSidebarState(false);
            }
        });

        sidebar.addEventListener('mouseleave', () => {
            if (!Store.state.ui.sidebarPinned) {
                updateSidebarState(true);
            }
        });

        document.getElementById('toggle-sidebar').addEventListener('click', (e) => {
            e.stopPropagation();
            Store.state.ui.sidebarPinned = !Store.state.ui.sidebarPinned;
            updateSidebarState(!Store.state.ui.sidebarPinned);
            Store.persist();
        });

        function updateSidebarState(collapsed) {
            Store.state.ui.sidebarCollapsed = collapsed;
            const sidebar = document.getElementById('sidebar');
            const toggleIcon = document.getElementById('sidebar-toggle-icon');
            const pinIcon = Store.state.ui.sidebarPinned ? 'pin' : 'pin-off';

            if (collapsed) {
                sidebar.classList.remove('w-64');
                sidebar.classList.add('w-16');
                sidebar.querySelectorAll('.sidebar-text').forEach(el => el.classList.add('hidden'));
            } else {
                sidebar.classList.add('w-64');
                sidebar.classList.remove('w-16');
                sidebar.querySelectorAll('.sidebar-text').forEach(el => el.classList.remove('hidden'));
            }

            toggleIcon.setAttribute('data-lucide', pinIcon);
            Router.renderSidebar();

            if (window.lucide) {
                lucide.createIcons({
                    attrs: { class: "w-4 h-4" },
                    nameAttr: 'data-lucide',
                    root: document.getElementById('toggle-sidebar')
                });
            }
        }

        // Initialize App
        Store.init();
        Router.init();
        debugLog('App Initialized v' + APP.version);

    </script>
</body>

</html>